'''
Created on 21 mei 2015

@author: e.schaeffer
updates
'''

from datetime import datetime
from pprint import pprint
import os
import sys
import time
import subprocess
import math
import numpy as np
import pygatt

from UliEngineering.Physics.RTD import pt1000_temperature
from Instruments.PH_Instr_34970A import Instrument_34970A
from Instruments.SerialInterface import SerialInterface
from Instruments.bled112_scanner import BLE_Scanner
from Instruments.Keysight_E36103A import Keysight_E36103A
import pyaudio
from settings.defines import *
from tests.settings_test import MSGOPTIONS
from module_locator import module_path

class TestFCTBold():
    toolreset_counter = 0
    msgflags = {}
    startfn = None
    clearfn = None

    def __init__(self, parent, hwsettings):
        self.parent = parent
        self.hwsettings = hwsettings
        self.settings = None

        self.startfn = self.relay_jigdown
        self.errorfn = self.errorHandler
        self.clearfn = self.relay_clrjig

        # list with methods for initialization
        self.instruments = [
            self.init_serial_dut,
            self.init_serial_led,
            self.init_gpib_dmm,
            self.init_psu,
            self.init_audio,
            self.init_ble
            # self.init_jlink,
            ]

        self.tests = [
            self.check_settings,            # OK
            self.init_values,               # OK
            self.jig_sanity_check,          # OK

            self.psu_start,
            self.dut_start,
            self.dut_battery_voltage,
            # self.dut_motor,
            # self.dut_accelerometer,
            # self.dut_magnetometer,
            # self.dut_button,
            self.dut_buzzer,
            self.dut_leds,
            self.dut_ble,

            self.dut_standby,

            self.timedone,
            self.stamp,
            self.relay_clrjig,
        ]

        self.values = {}

    def failtest(self):
        return False

    def log_add(self, msg):
        self.parent.log_add(msg)

    def setError(self, message):
        self.log_addline(message)
        self.values['error'] = message.strip()

    def setValue(self, value, key, label=None, fmt=None):
        if label is None:
            label = key
        if fmt is None:
            fmt = '{:s}'
        self.log_addline('{:s}: {:.2f}'.format(label))

    def storeValue(self, key, value):
        self.values[key.lower()] = value

    def log_addline(self, msg):
        self.log_add(msg + '\n')

    def setTestSettings(self, settings):
        self.settings = settings

    def check_settings(self):
        self.time_start = time.time()
#         if self.settings is None:
#             self.log_add('No settings loaded')
#             return False
        return True

    def timedone(self):
        elapsed = time.time() - self.time_start
        self.log_addline('Test time: {:.1f}sec'.format(elapsed))
        return True

    def init_values(self):
        self.values = {
            'datetime': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'testerid': self.hwsettings.general['testerid'],
            'testersw': title
        }

        if self.parent.parent.scannedBarcodeLine != '':
            self.values['qrcode'] = self.parent.parent.scannedBarcodeLine

        self.parent.logAddFilenamePrefix('FCT')
        self.parent.logAddFilenamePrefix(self.parent.barcode)

        return True

# INSTRUMENTS
    def init_psu(self):
        self.instrPSU = Keysight_E36103A()
        if self.instrPSU.connect_usb(self.hwsettings.psu['vid'],
                                     self.hwsettings.psu['pid']) is False:
            self.log_addline('  error connecting PSU')
            return False

        ret = self.instrPSU.Query('*IDN?')
        self.log_addline('  PSU init OK')
        self.log_addline('  PSU IDN: {:s}'.format(ret.strip()))

        self.instrPSU.Volt(0.0)
        self.instrPSU.Output_Off()

        return True

    def init_serial_dut(self):
        try :
            self.serDUT = SerialInterface(self.hwsettings.serial_dut['comport'],
                                          timeout=0.05,
                                          baudrate=115200,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False
                                          )
        except:
            self.log_addline('  USB connection / Comport nr ERROR')
            return False
        self.log_addline('  Serial DUT init OK')
        return True

    def init_serial_echo(self):
        try :
            self.serEcho = SerialInterface(self.hwsettings.serial_echo['comport'],
                                           timeout=0.05,
                                           baudrate=115200,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False
                                           )
            self.serEcho.flushInput()
            self.serEcho.flushOutput()
            self.serEcho.write('\r\n')
            time.sleep(.1)
        except:
            self.log_addline('  USB connection / Comport nr ERROR')
            return False
        self.log_addline('  Serial ECHO init OK')
        return True

    def init_serial_led(self):
        self.log_add('  Serial LED Analyser  ')
        if self.hwsettings.serial_led['enabled'] is False:
            # led analyzer is disabled
            self.log_addline('skipped')
            return True
        try:
            self.serLed = SerialInterface(self.hwsettings.serial_led['comport'],
                                          timeout=0.05,
                                          baudrate=57600,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False)
        except:
            self.log_addline('Comport error')
            return False
        self.log_addline('init OK')
        return True

    def init_gpib_dmm(self):
        self.instrDMM = Instrument_34970A(addr=self.hwsettings.dmm['address'])
        if self.instrDMM.error is True:
            self.log_addline('  error connecting DMM')
            return False

        ret = self.instrDMM.Query('*IDN?')
        self.log_addline('  DMM init OK')
        self.log_addline('  DMM IDN: {:s}'.format(ret.strip()))

        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)
        self.Deactivate_Relay(Ry_Takeover)

        return True

    def init_jlink(self):
        if self.hwsettings.firmware['program_test'] is False and self.hwsettings.firmware['program_app'] is False:
            self.log_addline('  JLink - skipping (disabled)')
            return True

        nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
        nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

        try:
            ret = subprocess.check_output([nrfjexe, '--ids'], shell=True)
        except:
            self.log_addline('  JLink - nrfjprog error')
            return False

        ret = ret.decode()
        ids = ret.split('\n')
        jlinkids = []
        for jlinkid in ids:
            if len(jlinkid) > 0:
                jlinkids.append(jlinkid.strip())

        if len(jlinkids) == 0:
            self.log_addline('  JLink Error: no devices found')
            return False

        if self.hwsettings.firmware['program_test']:
            hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_test'])
            if not os.path.isfile(hexfile):
                self.log_addline('  JLink - hex file {:s} not found'.format(hexfile))
                return False
        if self.hwsettings.firmware['program_app']:
            hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_app'])
            if not os.path.isfile(hexfile):
                self.log_addline('  JLink - hex file {:s} not found'.format(hexfile))
                return False

        self.log_addline('  JLink OK (s/n:{:s})'.format(jlinkids[0]))

        return True

    def init_audio(self):
        self.log_add('  Audio/Microphone')
        if self.hwsettings.microphone['enabled'] is False:
            self.log_addline('  skipped')
            return True

        FORMAT = pyaudio.paInt16
        CHANNELS = 1

        try:
            self.paudio = pyaudio.PyAudio()
            self.audio_stream = self.paudio.open(format = FORMAT,
                                                 channels = CHANNELS,
                                                 rate = 44100,
                                                 input = True,
                                                 output = False,
                                                 frames_per_buffer = 1024)
        except:
            self.log_addline('  FAIL, error initializing audio/microphone')
            return False

        self.log_addline('  PASS')
        return True

    def init_ble(self):
        self.ble_dongle = pygatt.BGAPIBackend(serial_port='COM12')
        self.ble_dongle.start()
        return True

    def ble_find_device(self, devname):
        # dongle = pygatt.BGAPIBackend(serial_port='COM12')
        # dongle.start()

        ADDRESS_TYPE = pygatt.BLEAddressType.random
        devices = self.ble_dongle.scan(run_as_root=True, timeout=2)

        UUID_DEVICE_NAME = '00002a00-0000-1000-8000-00805f9b34fb'

        for device in devices:
            # print(device['address'], device['rssi'])
            address = device['address']

            if device['rssi'] < -50:
                # print('low rssi, skipping')
                continue

            try:
                bledevice = self.ble_dongle.connect(address, address_type=ADDRESS_TYPE)
                try:
                    devicename = bledevice.char_read(UUID_DEVICE_NAME).decode()
                except:
                    continue
                print(devicename, device['rssi'])
                if devname in devicename:
                    return address, device['rssi']
                bledevice.disconnect()
            except pygatt.exceptions.NotConnectedError:
                # print("failed to connect to %s" % address)
                continue

        return False


    # when test exit perform nice instruments close (USB relay!)
    def closeInstruments(self):
        self.power_off()



# TESTS
    def psu_start(self):
        self.instrPSU.Volt(3.0)
        self.instrPSU.Amp(2.0)
        self.instrPSU.Output_On()

        self.log_addline('Switching PSU to 3.0V / 2.0A')

        currents = []
        for i in range(5):
            time.sleep(0.5)
            current = self.instrPSU.Measure_Amps() * 1000
            if i > 1:
                currents.append(current)

        current = sum(currents) / len(currents)
        self.log_addline(f'  current: {current:.1f}mA')
        return True

    def dut_start(self):
        self.Activate_Relay(Ry_SerialEnable)

        # sys.exit(0)
        lines = self.dutQuery('')
        lines = self.dutQuery('get_firmware_version?')
        for line in lines:
            if line == '':
                continue
            try:
                version = int(line)
            except:
                self.setError('error parsing version number')
                return False

            self.log_addline(f'DUT firmware version: {version}')
            return True
        return False

    def dut_battery_voltage(self):
        lines = self.dutQuery('read_battery_voltage?')  # dummy read
        lines = self.dutQuery('read_battery_voltage?')
        for line in lines:
            if line == '':
                continue

            try:
                battvoltage = int(line)
            except:
                self.setError('error parsing battery voltage')
                return False

            self.log_addline(f'battery voltage: {battvoltage}mV')
            return True
        return False

    def dut_motor(self):
        cmds = {
            'left': ('enable_motor_left', 0.5),
            'right': ('enable_motor_right', 0.5),
            'disable': ('disable_motor', 1.5)
        }

        results = {}
        for m, cmd_delay in cmds.items():
            cmd, delay = cmd_delay
            lines = self.dutQuery(cmd)
            motor_cmd_ok = False
            for line in lines:
                if line == '':
                    continue
                if line == 'OK':
                    motor_cmd_ok = True
                    break

            if motor_cmd_ok is False:
                self.setError(f'{cmd} FAIL')
                return False

            self.log_addline(f'{cmd} OK')

            time.sleep(delay)

            v = self.instrDMM.Measure_Volt_DC('100', 11, '10', '5.5')
            i = v / 25
            ipsu = self.instrPSU.Measure_Amps()
            self.log_addline(f'  voltage:     {v:.2f}V')
            self.log_addline(f'  current:     {i*1000:.1f}mA')
            self.log_addline(f'  psu current: {ipsu*1000:.1f}mA')

            results[m] = (v, i, ipsu)
            time.sleep(0.5)

        return True

    def dut_accelerometer(self):
        lines = self.dutQuery('read_accelerometer?')
        line = ''.join(lines)
        self.log_addline(f'accelerometer: {line}')
        return True

    def dut_magnetometer(self):
        lines = self.dutQuery('read_magnetometer?')
        line = ''.join(lines)
        self.log_addline(f'magnetometer:  {line}')
        return True

    def dut_button(self):
        self.log_addline('button')
        lines = self.dutQuery('read_button?')
        line = ''.join(lines)
        self.log_addline(f'  not pressed: {line}')

        time.sleep(0.5)

        self.Activate_Relay(Ry_Button)
        time.sleep(0.5)
        lines = self.dutQuery('read_button?')
        line = ''.join(lines)
        self.log_addline(f'  pressed:     {line}')
        self.Deactivate_Relay(Ry_Button)

        return True

    def audio_read(self, numsamples, label=None):
        if self.hwsettings.microphone['enabled'] is False:
            return 0
        data = self.audio_stream.read(numsamples)
        signal = np.fromstring(data, 'Int16')
        tot = sum(abs(x) for x in signal)
        tot = 20 * math.log10(tot)
        if label is not None:
            print(label, tot)
        return tot

    def dut_buzzer(self):
        self.log_addline('buzzer')
        _lines = self.dutQuery('enable_buzzer')
        time.sleep(0.2)
        dbon = self.audio_read(44100, 'ON')
        self.log_addline(f'  on:    {dbon:.1f} dB')

        time.sleep(0.5)

        _lines = self.dutQuery('disable_buzzer')
        self.audio_read(44100)
        self.audio_read(44100)
        dboff = self.audio_read(44100, 'OFF')
        self.log_addline(f'  off:   {dboff:.1f} dB')
        self.log_addline(f'  delta:    {dbon-dboff:.1f} dB')

        return True

    def dut_standby(self):
        self.log_addline('standby')
        _lines = self.dutQuery('enter_standby')
        self.Deactivate_Relay(Ry_SerialEnable)
        time.sleep(1)

        ipsu = self.instrPSU.Measure_Amps()
        self.log_addline(f'  psu current:     {ipsu*1_000_000:.1f}uA')
        if ipsu > 0.3e-3:
            self.setError('  standby psu current too high')
            return False

        self.Activate_Relay(Ry_10kResistor)
        time.sleep(0.5)

        vv = []
        for _i in range(4):
            v = self.instrDMM.Measure_Volt_DC('100', 16, '0.1', '5.5')
            time.sleep(0.5)
            vv.append(v)

        v = sum(vv) / len(vv)
        self.log_addline(f'  standby current: {v*1_000_000/10_000:.1f}uA')

        self.Deactivate_Relay(Ry_10kResistor)
        return True

    def dut_leds(self):
        if self.hwsettings.ledtest['analyzer_enable'] is False:
            return True
        cmds = {
            'green': 'enable_green_led',
            'red': 'enable_red_led',
            'blue': 'enable_blue_led'
        }

        self.log_addline('LEDs')
        for color, cmd in cmds.items():
            self.dutQuery(cmd)
            time.sleep(.25)
            leds = self.ledAnalyse([1,2])
            self.log_addline(f'  {color}')
            for ch in [1,2]:
                cr = leds[ch]['red']
                cg = leds[ch]['green']
                cb = leds[ch]['blue']
                ci = leds[ch]['intensity']
                self.log_addline(f'     {ch}: {cr:03d}, {cg:03d}, {cb:03d}, {ci}')

            self.dutQuery('disable_leds')
            time.sleep(.25)

        return True

    def dut_ble(self):
        self.log_addline('BLE')

        self.dutQuery('enable_ble_advertising')
        time.sleep(0.5)

        for i in range(2):
            ret = self.ble_find_device('Bold')
            if ret is not False:
                break

        if ret is False:
            self.setError('  device not found')
            return False

        address, rssi = ret
        self.log_addline(f'  address: {address}')
        self.log_addline(f'  RSSI:    {rssi}dBm')

        lines = self.dutQuery('disable_ble_advertising')
        return True

    def power_off(self):
        self.instrPSU.Output_Off()
        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)
        self.Deactivate_Relay(Ry_10kResistor)

        return True

    def jig_sanity_check(self, skipecho=False):
        value = self.instrDMM.Measure_Volt_DC('100', 18, '100', resolution = '5.5')
        self.log_addline('jig 24V: {:.1f}V'.format(value))
        self.storeValue('jig24v', value)
        if value < 20.0:
            self.setError('jig 24V FAIL')
            return False

        value = self.instrDMM.Measure_Ohm('100', 20)
        self.jigtemp = pt1000_temperature(value)
        self.log_addline('jig temperature: {:.1f}degC'.format(self.jigtemp))
        self.storeValue('jigtemp', self.jigtemp)

        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)

        return True


    # def firmwareTest(self):
    #     self.log_addline('Programming test firmware    ')
    #     if self.hwsettings.firmware['program_test'] is False:
    #         self.log_addline('  skipped')
    #         return True

    #     self.Activate_Relay(Ry_Jlink)
    #     self.Activate_Relay(Ry_SerialEnable)

    #     time.sleep(1)

    #     value = self.instrDMM.Measure_Volt_DC('100', 6,  '10')
    #     self.log_add('  programming voltage {:.2f}V    '.format(value))
    #     if value < self.hwsettings.firmware['1V8_bckp_min']:
    #         self.setError('  program voltage 1V8 too low')
    #         return False
    #     if value > self.hwsettings.firmware['1V8_bckp_max']:
    #         self.setError('  program voltage 1V8 too high')
    #         return False
    #     self.log_addline('PASS')

    #     nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
    #     nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

    #     hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_test'])

    #     if not os.path.exists(hexfile):
    #         self.setError('hexfile {:s} does not exist'.format(hexfile))
    #         return False

    #     self.log_add('  programming {:s}    '.format(self.hwsettings.firmware['hex_test']))
    #     try:
    #         ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--program', hexfile, '--chiperase'],
    #                             shell=True,
    #                             check=True)
    #     except:
    #         self.setError('FAIL')
    #         return False

    #     self.log_addline('PASS')

    #     time.sleep(0.5)


    #     self.Deactivate_Relay(Ry_Program)

    #     # powercycle
    #     self.instrPSU2306.Output_On(OUTPUT_BATTERY, False)
    #     self.instrPSU2306.Output_On(OUTPUT_CHARGE, False)

    #     time.sleep(3)

    #     self.instrPSU2306.Volt(OUTPUT_BATTERY,
    #                            self.hwsettings.battsim['nominal_voltage'])
    #     self.instrPSU2306.Amp(OUTPUT_BATTERY, 1.3)
    #     self.instrPSU2306.Output_On(OUTPUT_BATTERY, True)

    #     # try:
    #     #     ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--reset'],
    #     #                         shell=True,
    #     #                         check=True)
    #     # except:
    #     #     self.log_addline('  running processor FAIL')
    #     #     return False

    #     # self.log_addline('  running processor PASS')
    #     # self.Deactivate_Relay(Ry_Program)


    #     time.sleep(0.5)

    #     return True

    # def firmwareApplication(self):
    #     self.log_addline('Programming application firmware    ')
    #     if self.hwsettings.firmware['program_app'] is False:
    #         self.log_addline('  skipped')
    #         return True

    #     self.Activate_Relay(Ry_Program)

    #     value = self.instrDMM.Measure_Volt_DC('100', 6,  '10')
    #     self.log_add('  programming voltage {:.2f}V    '.format(value))
    #     if value < self.hwsettings.firmware['1V8_bckp_min']:
    #         self.setError('  program voltage 1V8 too low')
    #         return False
    #     if value > self.hwsettings.firmware['1V8_bckp_max']:
    #         self.setError('  program voltage 1V8 too high')
    #         return False
    #     self.log_addline('PASS')

    #     nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
    #     nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

    #     hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_app'])

    #     if not os.path.exists(hexfile):
    #         self.setError('hexfile {:s} does not exist'.format(hexfile))
    #         return False

    #     self.log_add('  programming {:s}    '.format(self.hwsettings.firmware['hex_app']))
    #     try:
    #         ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--program', hexfile, '--chiperase'],
    #                             shell=True,
    #                             check=True)
    #     except:
    #         self.setError('FAIL')
    #         return False

    #     self.log_addline('PASS')

    #     time.sleep(0.5)

    #     self.Deactivate_Relay(Ry_Program)

    #     # powercycle
    #     self.instrPSU2306.Output_On(OUTPUT_BATTERY, False)
    #     self.instrPSU2306.Output_On(OUTPUT_CHARGE, False)

    #     time.sleep(3)

    #     self.instrPSU2306.Volt(OUTPUT_BATTERY,
    #                            self.hwsettings.battsim['nominal_voltage'])
    #     self.instrPSU2306.Amp(OUTPUT_BATTERY, 1.3)
    #     self.instrPSU2306.Output_On(OUTPUT_BATTERY, True)

    #     # try:
    #     #     ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--run'],
    #     #                         shell=True,
    #     #                         check=True)
    #     # except:
    #     #     self.log_addline('  running processor FAIL')
    #     #     return False

    #     self.log_addline('  running processor PASS')
    #     time.sleep(0.5)

    #     return True


    def debugexit(self):
        self.Activate_Relay(Ry_SerialEnable)
        time.sleep(1)
        sys.exit()


    def led(self):
        if self.hwsettings.ledtest['analyzer_enable'] is False:
            return True

        values = {
            'r': 'red',
            'g': 'green',
            'off': 'off'
        }
        limits = self.hwsettings.ledtest['limits']
        self.log_addline('LED')
        self.log_addline('  {:8s}{:6s}{:6s}{:6s}{:s}'.format('color', 'R', 'G', 'B', 'intensity'))
        for value, label in values.items():
            self.log_add('  {:8s}'.format(label))
            ledpass = False
            lines = self.dutQuery('LED '+value, 2, 'PASS')
            for line in lines:
                if 'RESP LED PASS' in line:
                    # self.log_add('PASS\n')
                    ledpass = True
            if ledpass is False:
                self.setError('FAIL')
                return False

            ret = self.ledAnalyse()
            self.log_add('{:3d}   {:3d}   {:3d}   {:5d}       '.format(ret['red'],
                                                                       ret['green'],
                                                                       ret['blue'],
                                                                       ret['intensity']))
            if value == 'r':
                if ret['red'] < limits['red_min']:
                    self.setError('FAIL - red too low')
                    return False
                if ret['green'] > limits['off_max']:
                    self.setError('FAIL - green too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] < limits['intensity_min']:
                    self.setError('FAIL - intensity too low')
                    return False
                if ret['intensity'] > limits['intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False
            elif value == 'g':
                if ret['green'] < limits['green_min']:
                    self.setError('FAIL - green too low')
                    return False
                if ret['red'] > limits['off_max']:
                    self.setError('FAIL - red too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] < limits['intensity_min']:
                    self.setError('FAIL - intensity too low')
                    return False
                if ret['intensity'] > limits['intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False
            elif value == 'off':
                if ret['red'] > limits['off_max']:
                    self.setError('FAIL - red too high')
                    return False
                if ret['green'] > limits['off_max']:
                    self.setError('FAIL - green too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] > limits['off_intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False

            self.log_addline('PASS')

            time.sleep(self.hwsettings.ledtest['led2led_delay'])

        return True


    def ble_scan(self, message, testfw=False):
        self.log_addline(message)
        if self.hwsettings.ble['test_enable'] is False:
            self.log_addline('  skipped (test disabled)')
            return True

        # print('EMPTY SCANNING ')
        self.blescan.scanInit()
        # print('blescan init done')
        # start=time.time()
        # self.log_add('  pre scan')
        # dottime = time.time()
        # while time.time() - start < self.hwsettings.ble['dummy_scan_time']:
        #     _data = self.blescan.scan('')
        #     if time.time() - dottime > 0.5:
        #         self.log_add('.')
        #         dottime = time.time()
        # self.log_addline('')

        if testfw is True:
            self.log_addline('  BLE radio ON')
            lines = self.dutQuery('BLE on', 2, 'PASS')
            for _line in lines:
                # print('line', line)
                pass
            time.sleep(1)

        # print('SCANNING FOR TN027')
        results = []
        error = False
        for _i in range(self.hwsettings.ble['num_scans']):
            ret = self.blescan.scan(self.hwsettings.ble['scan_device'],
                                    self.hwsettings.ble['scan_timeout'])
            if ret:
                self.log_addline('    {:s}, MAC {:s}, rssi {:s}dBm'.format(ret['data'].strip(),
                                                                           ret['sender'],
                                                                           ret['rssi']))
                rssi = float(ret['rssi'])
                results.append(rssi)
            else:
                self.log_addline('    ...')

        if len(results) == 0:
            self.setError('FAIL, BLE beacon not found')
            return False

        rssi = max(results)
        self.log_add('  Best rssi: {:.0f}dBm    '.format(rssi))
        if rssi < self.hwsettings.ble['rssi_min']:
            self.setError('FAIL')
            error = True
        else:
            self.log_addline('PASS')

        time.sleep(0.5)

        if testfw is True:
            self.log_addline('  BLE radio OFF')
            lines = self.dutQuery('BLE off', 2, 'PASS')
            for line in lines:
                # print('line', line)
                pass
            time.sleep(1)

        if error:
            return False

        return True

    def ble_test(self):
        return self.ble_scan('BLE test', True)

    def ble_app(self):
        if self.hwsettings.firmware['program_app'] is False:
            return True
        return self.ble_scan('BLE checking for application firmware beacon', False)

    def dutQuery(self, cmd, timeout=None, findstr=None):
        self.serDUT.write(cmd+'\r')
        if timeout is None:
            ret = self.serDUT._readlines(findstr=findstr)
        else:
            ret = self.serDUT._readlines(timeout=timeout,
                                         findstr=findstr)
        lines = ret.split('\n')
        output = []
        for line in lines:
            output.append(line.strip())
        return output

    def ledAnalyse(self, channels):
        if self.hwsettings.ledtest['analyzer_enable'] is False:
            return True

        _start = time.time()
        brightness_level = self.hwsettings.ledtest['brightness_level']
        if brightness_level in [1,2,3,4,5]:
            self.serLed.write('C{:d}\r\n'.format(brightness_level))
        else:
            self.serLed.write('C\r\n')

        ret = self.serLed._readlines(timeout=0.5, findstr='OK')

        leds = {}
        for channel in channels:
            self.serLed.write('getrgbi{:02d}\r\n'.format(channel))
            ret = self.serLed.readlines()

            lines = ''
            for line in ret:
                lines += line.decode()

            print(channel, lines)
            lines = lines.split('\n')
            led = {}
            for line in lines:
                if line == '':
                    continue

                items = line.strip().split(' ')

                try:
                    led = {
                        'red': int(items[0]),
                        'green': int(items[1]),
                        'blue': int(items[2]),
                        'intensity': int(items[3])
                    }
                except:
                    continue
            leds[channel] = led

        _end = time.time()
#         print('elapsed getall', end-start)
        return leds



    def stamp(self):
        self.Activate_Relay(Ry_Stamp)
        time.sleep(self.hwsettings.general['stamp_delay'])
        self.Deactivate_Relay(Ry_Stamp)
        return True


    def message(self):
        flag = False
        message = ''
        for msg in self.settings.messages:
            for opt in MSGOPTIONS:
                if msg[opt] is not None:
                    if msg[opt] in self.msgflags[opt]:
                        flag = True
                    else:
                        flag = False
            if flag:
                message = msg['message']
                break

        if flag:
            self.parent.action_update(message, 0)
            pass


    # take over the pneumatic valve, keep jig down
    def relay_jigdown(self):
        return False

    def relay_setjig(self):
        return True

    def relay_clrjig(self):
        self.power_off()
        return True

    def errorHandler(self):
        return True

    def Activate_Relay(self, port=(200,2,0)):
        self.instrDMM.A34907A_Digital_Output_bit(str(port[0]),port[1],port[2],True)

    def Deactivate_Relay(self, port=(200,2,0)):
        self.instrDMM.A34907A_Digital_Output_bit(str(port[0]),port[1],port[2],False)
