'''
Created on 21 mei 2015

@author: e.schaeffer
updates
'''

from datetime import datetime
from pprint import pprint
import os
import sys
import time
import subprocess

from UliEngineering.Physics.RTD import pt1000_temperature
from Instruments.PH_Instr_34970A import Instrument_34970A
from Instruments.SerialInterface import SerialInterface
from Instruments.bled112_scanner import BLE_Scanner
from Instruments.Keysight_E36103A import Keysight_E36103A
from settings.defines import *
from tests.settings_test import MSGOPTIONS
from module_locator import module_path

class TestFCTBold():
    toolreset_counter = 0
    msgflags = {}
    startfn = None
    clearfn = None

    def __init__(self, parent, hwsettings):
        self.parent = parent
        self.hwsettings = hwsettings
        self.settings = None

        self.startfn = self.relay_jigdown
        self.errorfn = self.errorHandler
        self.clearfn = self.relay_clrjig

        # list with methods for initialization
        self.instruments = [
            self.init_serial_dut,
            # self.init_serial_led,
            self.init_gpib_dmm,
            self.init_psu,
            # self.init_gpib_battsim,
            # self.init_blescanner,
            # self.init_jlink,
            # self.init_hackrf_one,
            ]

        # list with tests to perform
        self.tests_old = [
            self.check_settings,            # OK
            self.init_values,               # OK
            self.jig_sanity_check,          # OK

        #     self.initBattery,
        #     self.timedone,
        #     self.firmwareTest,
        #     self.timedone,
        #     self.measureBattery,
        #     self.timedone,
        #     self.dutBoot,
        #     self.timedone,
        #     self.gpsStart,
        #     self.timedone,
        #     # self.debugexit,

        #     self.selftestStart,
        #     self.timedone,
        #     self.emmc,
        #     self.timedone,
        #     self.temperature,
        #     self.timedone,
        #     self.accelerometer,
        #     self.timedone,
        #     self.led,
        #     self.timedone,
        #     self.ble_test,
        #     self.timedone,
        #     self.charge,
        #     self.timedone,
        #     self.usb_enable,
        #     self.timedone,
        #     self.usb_test,
        #     self.timedone,
        #     self.selftestResults,
        #     self.timedone,
        #     self.gpsResults,
        #     self.timedone,
        #     self.measureBatteryIdle,
        #     self.timedone,
        #     self.firmwareApplication,
        #     self.timedone,
        #     # self.measureBatteryIdle2,
        #     # self.timedone,
        #     self.ble_app,
        #     # self.timedone,
        #     # self.measureBatteryIdle,

        #     self.timedone,
        #     self.stamp,
        #     self.relay_clrjig,
        ]

        # _test_start = [
        #     self.check_settings,            # OK
        #     self.init_values,               # OK

        #     self.jig_sanity_check,          # OK
        #     ]

        # _test_end = [
        #     self.timedone,

        #     self.stamp,
        #     self.relay_clrjig,
        #]

        self.tests = [
            self.check_settings,            # OK
            self.init_values,               # OK
            self.jig_sanity_check,          # OK
        ]

#         for key in sorted(self.hwsettings.tests.keys()):

        self.values = {}

    def failtest(self):
        return False

    def log_add(self, msg):
        self.parent.log_add(msg)

    def setError(self, message):
        self.log_addline(message)
        self.values['error'] = message.strip()

    def setValue(self, value, key, label=None, fmt=None):
        if label is None:
            label = key
        if fmt is None:
            fmt = '{:s}'
        self.log_addline('{:s}: {:.2f}'.format(label))

    def storeValue(self, key, value):
        self.values[key.lower()] = value

    def log_addline(self, msg):
        self.log_add(msg + '\n')

    def setTestSettings(self, settings):
        self.settings = settings

    def check_settings(self):
        self.time_start = time.time()
#         if self.settings is None:
#             self.log_add('No settings loaded')
#             return False
        return True

    def timedone(self):
        elapsed = time.time() - self.time_start
        self.log_addline('Test time: {:.1f}sec'.format(elapsed))
        return True

    def init_values(self):
        self.values = {
            'datetime': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'testerid': self.hwsettings.general['testerid'],
            'testersw': title
        }

        if self.parent.parent.scannedBarcodeLine != '':
            self.values['qrcode'] = self.parent.parent.scannedBarcodeLine

        self.parent.logAddFilenamePrefix('FCT')
        self.parent.logAddFilenamePrefix(self.parent.barcode)

        return True

# INSTRUMENTS
    def init_psu(self):
        self.instrPSU = Keysight_E36103A()
        if self.instrPSU.connect_usb(self.hwsettings.psu['vid'],
                                     self.hwsettings.psu['pid']) is False:
            self.log_addline('  error connecting PSU')
            return False

        ret = self.instrPSU.Query('*IDN?')
        self.log_addline('  PSU init OK')
        self.log_addline('  PSU IDN: {:s}'.format(ret.strip()))

        self.instrPSU.Volt(0.0)
        self.instrPSU.Output_Off()

        return True

    def init_serial_dut(self):
        try :
            self.serDUT = SerialInterface(self.hwsettings.serial_dut['comport'],
                                          timeout=0.05,
                                          baudrate=115200,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False
                                          )
        except:
            self.log_addline('  USB connection / Comport nr ERROR')
            return False
        self.log_addline('  Serial DUT init OK')
        return True

    def init_serial_echo(self):
        try :
            self.serEcho = SerialInterface(self.hwsettings.serial_echo['comport'],
                                           timeout=0.05,
                                           baudrate=115200,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False
                                           )
            self.serEcho.flushInput()
            self.serEcho.flushOutput()
            self.serEcho.write('\r\n')
            time.sleep(.1)
        except:
            self.log_addline('  USB connection / Comport nr ERROR')
            return False
        self.log_addline('  Serial ECHO init OK')
        return True

    def init_serial_led(self):
        self.log_add('  Serial LED Analyser  ')
        if self.hwsettings.serial_led['enabled'] is False:
            # led analyzer is disabled
            self.log_addline('skipped')
            return True
        try:
            self.serLed = SerialInterface(self.hwsettings.serial_led['comport'],
                                          timeout=0.05,
                                          baudrate=57600,
                                          xonxoff=True,
                                          rtscts=False,
                                          dsrdtr=False)
        except:
            self.log_addline('Comport error')
            return False
        self.log_addline('init OK')
        return True

    def init_blescanner(self):
        self.blescan = BLE_Scanner()
        ret = self.blescan.connect(self.hwsettings.ble['comport'])
        if ret is False:
            self.log_addline('  BLE Scanner 1 error')
            return False
        try:
            self.blescan.scanInit()
        except:
            self.log_addline('  BLE Scanner  2 error')
            return False
        self.log_addline('  BLE Scanner Init OK')
        return True

    def init_gpib_dmm(self):
        self.instrDMM = Instrument_34970A(addr=self.hwsettings.dmm['address'])
        if self.instrDMM.error is True:
            self.log_addline('  error connecting DMM')
            return False

        ret = self.instrDMM.Query('*IDN?')
        self.log_addline('  DMM init OK')
        self.log_addline('  DMM IDN: {:s}'.format(ret.strip()))

        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)
        self.Deactivate_Relay(Ry_Takeover)

        return True

    def init_jlink(self):
        if self.hwsettings.firmware['program_test'] is False and self.hwsettings.firmware['program_app'] is False:
            self.log_addline('  JLink - skipping (disabled)')
            return True

        nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
        nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

        try:
            ret = subprocess.check_output([nrfjexe, '--ids'], shell=True)
        except:
            self.log_addline('  JLink - nrfjprog error')
            return False

        ret = ret.decode()
        ids = ret.split('\n')
        jlinkids = []
        for jlinkid in ids:
            if len(jlinkid) > 0:
                jlinkids.append(jlinkid.strip())

        if len(jlinkids) == 0:
            self.log_addline('  JLink Error: no devices found')
            return False

        if self.hwsettings.firmware['program_test']:
            hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_test'])
            if not os.path.isfile(hexfile):
                self.log_addline('  JLink - hex file {:s} not found'.format(hexfile))
                return False
        if self.hwsettings.firmware['program_app']:
            hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_app'])
            if not os.path.isfile(hexfile):
                self.log_addline('  JLink - hex file {:s} not found'.format(hexfile))
                return False

        self.log_addline('  JLink OK (s/n:{:s})'.format(jlinkids[0]))

        return True

    def init_hackrf_one(self):
        if self.hwsettings.gps['enabled'] is False:
            self.log_addline('  GPS test skipped')
            return True

        hackrf_info = os.path.join(self.hwsettings.gps['hackrf_path'], 'hackrf_info')

        try:
            ret = subprocess.check_output([hackrf_info], shell=True)
        except:
            self.log_addline('  GPS testtool - no devices found')
            return False

        info = ret.decode()
        if 'No HackRF boards found' in info:
            self.log_addline('  GPS testtool - no devices found')
            return False

        if not os.path.isfile(self.hwsettings.gps['gps_bin']):
            self.log_addline('  GPS testtool - bin file {:s} not found'.format(self.hwsettings.gps['gps_bin']))
            return False

        self.log_addline('  GPS testtool - device found')

        self.gps_test_count = 0

        return True


    # when test exit perform nice instruments close (USB relay!)
    def closeInstruments(self):
        self.power_off()



# TESTS
    def power_off(self):
        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)

        return True


    def jig_sanity_check(self, skipecho=False):
        value = self.instrDMM.Measure_Volt_DC('100', 18, '100', resolution = '5.5')
        self.log_addline('jig 24V: {:.1f}V'.format(value))
        self.storeValue('jig24v', value)
        if value < 20.0:
            self.setError('jig 24V FAIL')
            return False

        value = self.instrDMM.Measure_Ohm('100', 20)
        self.jigtemp = pt1000_temperature(value)
        self.log_addline('jig temperature: {:.1f}degC'.format(self.jigtemp))
        self.storeValue('jigtemp', self.jigtemp)

        self.Deactivate_Relay(Ry_Stamp)
        self.Deactivate_Relay(Ry_SerialEnable)

        return True


    def firmwareTest(self):
        self.log_addline('Programming test firmware    ')
        if self.hwsettings.firmware['program_test'] is False:
            self.log_addline('  skipped')
            return True

        self.Activate_Relay(Ry_Jlink)
        self.Activate_Relay(Ry_SerialEnable)

        time.sleep(1)

        value = self.instrDMM.Measure_Volt_DC('100', 6,  '10')
        self.log_add('  programming voltage {:.2f}V    '.format(value))
        if value < self.hwsettings.firmware['1V8_bckp_min']:
            self.setError('  program voltage 1V8 too low')
            return False
        if value > self.hwsettings.firmware['1V8_bckp_max']:
            self.setError('  program voltage 1V8 too high')
            return False
        self.log_addline('PASS')

        nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
        nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

        hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_test'])

        if not os.path.exists(hexfile):
            self.setError('hexfile {:s} does not exist'.format(hexfile))
            return False

        self.log_add('  programming {:s}    '.format(self.hwsettings.firmware['hex_test']))
        try:
            ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--program', hexfile, '--chiperase'],
                                shell=True,
                                check=True)
        except:
            self.setError('FAIL')
            return False

        self.log_addline('PASS')

        time.sleep(0.5)


        self.Deactivate_Relay(Ry_Program)

        # powercycle
        self.instrPSU2306.Output_On(OUTPUT_BATTERY, False)
        self.instrPSU2306.Output_On(OUTPUT_CHARGE, False)

        time.sleep(3)

        self.instrPSU2306.Volt(OUTPUT_BATTERY,
                               self.hwsettings.battsim['nominal_voltage'])
        self.instrPSU2306.Amp(OUTPUT_BATTERY, 1.3)
        self.instrPSU2306.Output_On(OUTPUT_BATTERY, True)

        # try:
        #     ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--reset'],
        #                         shell=True,
        #                         check=True)
        # except:
        #     self.log_addline('  running processor FAIL')
        #     return False

        # self.log_addline('  running processor PASS')
        # self.Deactivate_Relay(Ry_Program)


        time.sleep(0.5)

        return True

    def firmwareApplication(self):
        self.log_addline('Programming application firmware    ')
        if self.hwsettings.firmware['program_app'] is False:
            self.log_addline('  skipped')
            return True

        self.Activate_Relay(Ry_Program)

        value = self.instrDMM.Measure_Volt_DC('100', 6,  '10')
        self.log_add('  programming voltage {:.2f}V    '.format(value))
        if value < self.hwsettings.firmware['1V8_bckp_min']:
            self.setError('  program voltage 1V8 too low')
            return False
        if value > self.hwsettings.firmware['1V8_bckp_max']:
            self.setError('  program voltage 1V8 too high')
            return False
        self.log_addline('PASS')

        nrfjprogpath = self.hwsettings.firmware['nrfjprog_path']
        nrfjexe = os.path.join(nrfjprogpath, 'nrfjprog.exe')

        hexfile = os.path.join(self.hwsettings.firmware['firmware_path'], self.hwsettings.firmware['hex_app'])

        if not os.path.exists(hexfile):
            self.setError('hexfile {:s} does not exist'.format(hexfile))
            return False

        self.log_add('  programming {:s}    '.format(self.hwsettings.firmware['hex_app']))
        try:
            ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--program', hexfile, '--chiperase'],
                                shell=True,
                                check=True)
        except:
            self.setError('FAIL')
            return False

        self.log_addline('PASS')

        time.sleep(0.5)

        self.Deactivate_Relay(Ry_Program)

        # powercycle
        self.instrPSU2306.Output_On(OUTPUT_BATTERY, False)
        self.instrPSU2306.Output_On(OUTPUT_CHARGE, False)

        time.sleep(3)

        self.instrPSU2306.Volt(OUTPUT_BATTERY,
                               self.hwsettings.battsim['nominal_voltage'])
        self.instrPSU2306.Amp(OUTPUT_BATTERY, 1.3)
        self.instrPSU2306.Output_On(OUTPUT_BATTERY, True)

        # try:
        #     ret = subprocess.run([nrfjexe, '-f', 'NRF52', '--run'],
        #                         shell=True,
        #                         check=True)
        # except:
        #     self.log_addline('  running processor FAIL')
        #     return False

        self.log_addline('  running processor PASS')
        time.sleep(0.5)

        return True


    def debugexit(self):
        self.Activate_Relay(Ry_SerialEnable)
        time.sleep(1)
        sys.exit()


    def dutBoot(self):
        self.log_addline('Enable serial communication')
        # enable serial communication
        self.Activate_Relay(Ry_SerialEnable)
        time.sleep(0.2)

        self.serDUT.write('\r\n')
        for i in range(100):
            line = self.serDUT.read()
            try:
                if '>' in line.decode():
                    break
            except:
                pass
            time.sleep(0.1)

        lines = self.dutQuery('VER', 3, 'RESP VER PASS')
        for line in lines:
            if 'RESP VER PASS' in line:
                version = line.replace('RESP VER PASS', '').strip()
                self.log_addline('firmware version: {:s}'.format(version))
                self.storeValue('version', version)
                return True
        time.sleep(1)


        self.setError('firmware version not found')
        return False

    def led(self):
        if self.hwsettings.ledtest['analyzer_enable'] is False:
            return True

        values = {
            'r': 'red',
            'g': 'green',
            'off': 'off'
        }
        limits = self.hwsettings.ledtest['limits']
        self.log_addline('LED')
        self.log_addline('  {:8s}{:6s}{:6s}{:6s}{:s}'.format('color', 'R', 'G', 'B', 'intensity'))
        for value, label in values.items():
            self.log_add('  {:8s}'.format(label))
            ledpass = False
            lines = self.dutQuery('LED '+value, 2, 'PASS')
            for line in lines:
                if 'RESP LED PASS' in line:
                    # self.log_add('PASS\n')
                    ledpass = True
            if ledpass is False:
                self.setError('FAIL')
                return False

            ret = self.ledAnalyse()
            self.log_add('{:3d}   {:3d}   {:3d}   {:5d}       '.format(ret['red'],
                                                                       ret['green'],
                                                                       ret['blue'],
                                                                       ret['intensity']))
            if value == 'r':
                if ret['red'] < limits['red_min']:
                    self.setError('FAIL - red too low')
                    return False
                if ret['green'] > limits['off_max']:
                    self.setError('FAIL - green too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] < limits['intensity_min']:
                    self.setError('FAIL - intensity too low')
                    return False
                if ret['intensity'] > limits['intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False
            elif value == 'g':
                if ret['green'] < limits['green_min']:
                    self.setError('FAIL - green too low')
                    return False
                if ret['red'] > limits['off_max']:
                    self.setError('FAIL - red too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] < limits['intensity_min']:
                    self.setError('FAIL - intensity too low')
                    return False
                if ret['intensity'] > limits['intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False
            elif value == 'off':
                if ret['red'] > limits['off_max']:
                    self.setError('FAIL - red too high')
                    return False
                if ret['green'] > limits['off_max']:
                    self.setError('FAIL - green too high')
                    return False
                if ret['blue'] > limits['off_max']:
                    self.setError('FAIL - blue too high')
                    return False
                if ret['intensity'] > limits['off_intensity_max']:
                    self.setError('FAIL - intensity too high')
                    return False

            self.log_addline('PASS')

            time.sleep(self.hwsettings.ledtest['led2led_delay'])

        return True


    def ble_scan(self, message, testfw=False):
        self.log_addline(message)
        if self.hwsettings.ble['test_enable'] is False:
            self.log_addline('  skipped (test disabled)')
            return True

        # print('EMPTY SCANNING ')
        self.blescan.scanInit()
        # print('blescan init done')
        # start=time.time()
        # self.log_add('  pre scan')
        # dottime = time.time()
        # while time.time() - start < self.hwsettings.ble['dummy_scan_time']:
        #     _data = self.blescan.scan('')
        #     if time.time() - dottime > 0.5:
        #         self.log_add('.')
        #         dottime = time.time()
        # self.log_addline('')

        if testfw is True:
            self.log_addline('  BLE radio ON')
            lines = self.dutQuery('BLE on', 2, 'PASS')
            for line in lines:
                # print('line', line)
                pass
            time.sleep(1)

        # print('SCANNING FOR TN027')
        results = []
        error = False
        for _i in range(self.hwsettings.ble['num_scans']):
            ret = self.blescan.scan(self.hwsettings.ble['scan_device'],
                                    self.hwsettings.ble['scan_timeout'])
            if ret:
                self.log_addline('    {:s}, MAC {:s}, rssi {:s}dBm'.format(ret['data'].strip(),
                                                                           ret['sender'],
                                                                           ret['rssi']))
                rssi = float(ret['rssi'])
                results.append(rssi)
            else:
                self.log_addline('    ...')

        if len(results) == 0:
            self.setError('FAIL, BLE beacon not found')
            return False

        rssi = max(results)
        self.log_add('  Best rssi: {:.0f}dBm    '.format(rssi))
        if rssi < self.hwsettings.ble['rssi_min']:
            self.setError('FAIL')
            error = True
        else:
            self.log_addline('PASS')

        time.sleep(0.5)

        if testfw is True:
            self.log_addline('  BLE radio OFF')
            lines = self.dutQuery('BLE off', 2, 'PASS')
            for line in lines:
                # print('line', line)
                pass
            time.sleep(1)

        if error:
            return False

        return True

    def ble_test(self):
        return self.ble_scan('BLE test', True)

    def ble_app(self):
        if self.hwsettings.firmware['program_app'] is False:
            return True
        return self.ble_scan('BLE checking for application firmware beacon', False)

    def dutQuery(self, cmd, timeout=None, findstr=None):
        self.serDUT.write(cmd+'\r\n')
        if timeout is None:
            ret = self.serDUT._readlines(findstr=findstr)
        else:
            ret = self.serDUT._readlines(timeout=timeout,
                                         findstr=findstr)
        lines = ret.split('\n')
        for line in lines:
            yield line.strip()

    def ledAnalyse(self):
        if self.hwsettings.ledtest['analyzer_enable'] is False:
            return True

        _start = time.time()
        brightness_level = self.hwsettings.ledtest['brightness_level']
        if brightness_level in [1,2,3,4,5]:
            self.serLed.write('C{:d}\r\n'.format(brightness_level))
        else:
            self.serLed.write('C\r\n')

        ret = self.serLed._readlines(timeout=0.5, findstr='OK')

        self.serLed.write('getrgbi01\r\n')
        ret = self.serLed.readlines()

        leds = {}
        lines = ''
        for line in ret:
            lines += line.decode()

        lines = lines.split('\n')
        for line in lines:
            if line == '':
                continue

            items = line.strip().split(' ')

            try:
                led = {
                    'red': int(items[0]),
                    'green': int(items[1]),
                    'blue': int(items[2]),
                    'intensity': int(items[3])
                }
            except:
                continue

        _end = time.time()
#         print('elapsed getall', end-start)
        return led



    def stamp(self):
        self.Activate_Relay(Ry_Stamp)
        time.sleep(self.hwsettings.general['stamp_delay'])
        self.Deactivate_Relay(Ry_Stamp)
        return True


    def message(self):
        flag = False
        message = ''
        for msg in self.settings.messages:
            for opt in MSGOPTIONS:
                if msg[opt] is not None:
                    if msg[opt] in self.msgflags[opt]:
                        flag = True
                    else:
                        flag = False
            if flag:
                message = msg['message']
                break

        if flag:
            self.parent.action_update(message, 0)
            pass


    # take over the pneumatic valve, keep jig down
    def relay_jigdown(self):
        return False
#         if self.usbrelay.Get_Input(2) == 1:
#             return True
#         return False


    def relay_setjig(self):
#         self.usbrelay.Set_Relay(1)
        return True


    def relay_clrjig(self):
        self.power_off()
        return True

    def errorHandler(self):
        self.gpsHackrfStop()
        return True

    def Activate_Relay(self,port=(200,2,0)):
        self.instrDMM.A34907A_Digital_Output_bit(str(port[0]),port[1],port[2],True)

    def Deactivate_Relay(self,port=(200,2,0)):
        self.instrDMM.A34907A_Digital_Output_bit(str(port[0]),port[1],port[2],False)

